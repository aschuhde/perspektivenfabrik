/**
 * WebApi
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { ApplicationDeleteProjectDeleteProjectDeleteProjectRequest } from '../model/applicationDeleteProjectDeleteProjectDeleteProjectRequest';
import { ApplicationDeleteProjectDeleteProjectDeleteProjectResponse } from '../model/applicationDeleteProjectDeleteProjectDeleteProjectResponse';
import { ApplicationExampleAnonymousGetExampleAnonymousGetExampleAnonymousResponse } from '../model/applicationExampleAnonymousGetExampleAnonymousGetExampleAnonymousResponse';
import { ApplicationExampleGetExampleGetExampleResponse } from '../model/applicationExampleGetExampleGetExampleResponse';
import { ApplicationGetAutocompleteEntriesGetAutocompleteEntriesGetAutocompleteEntriesResponse } from '../model/applicationGetAutocompleteEntriesGetAutocompleteEntriesGetAutocompleteEntriesResponse';
import { ApplicationGetInternalProjectGetInternalProjectGetInternalProjectResponse } from '../model/applicationGetInternalProjectGetInternalProjectGetInternalProjectResponse';
import { ApplicationGetJsonTypeDiscriminatorNamesGetJsonTypeDiscriminatorNamesGetJsonTypeDiscriminatorNamesResponse } from '../model/applicationGetJsonTypeDiscriminatorNamesGetJsonTypeDiscriminatorNamesGetJsonTypeDiscriminatorNamesResponse';
import { ApplicationGetOtpStatusGetOtpStatusGetOtpStatusResponse } from '../model/applicationGetOtpStatusGetOtpStatusGetOtpStatusResponse';
import { ApplicationGetPendingApprovalProjectsGetPendingApprovalProjectsGetPendingApprovalProjectsResponse } from '../model/applicationGetPendingApprovalProjectsGetPendingApprovalProjectsGetPendingApprovalProjectsResponse';
import { ApplicationGetProjectGetProjectGetProjectResponse } from '../model/applicationGetProjectGetProjectGetProjectResponse';
import { ApplicationGetProjectImageGetProjectImageGetProjectImageResponse } from '../model/applicationGetProjectImageGetProjectImageGetProjectImageResponse';
import { ApplicationGetProjectsGetProjectsGetProjectsResponse } from '../model/applicationGetProjectsGetProjectsGetProjectsResponse';
import { ApplicationGetUsersProjectGetUsersProjectGetUsersProjectResponse } from '../model/applicationGetUsersProjectGetUsersProjectGetUsersProjectResponse';
import { ApplicationGetUsersProjectsGetUsersProjectsGetUsersProjectsResponse } from '../model/applicationGetUsersProjectsGetUsersProjectsGetUsersProjectsResponse';
import { ApplicationJwtRefreshTokenJwtRefreshTokenJwtRefreshTokenRequest } from '../model/applicationJwtRefreshTokenJwtRefreshTokenJwtRefreshTokenRequest';
import { ApplicationJwtRefreshTokenJwtRefreshTokenJwtRefreshTokenResponse } from '../model/applicationJwtRefreshTokenJwtRefreshTokenJwtRefreshTokenResponse';
import { ApplicationJwtTokenJwtTokenRequest } from '../model/applicationJwtTokenJwtTokenRequest';
import { ApplicationJwtTokenJwtTokenResponse } from '../model/applicationJwtTokenJwtTokenResponse';
import { ApplicationPostConfirmOtpPostConfirmOtpPostConfirmOtpRequest } from '../model/applicationPostConfirmOtpPostConfirmOtpPostConfirmOtpRequest';
import { ApplicationPostConfirmOtpPostConfirmOtpPostConfirmOtpResponse } from '../model/applicationPostConfirmOtpPostConfirmOtpPostConfirmOtpResponse';
import { ApplicationPostProjectImagePostProjectImagePostProjectImageRequest } from '../model/applicationPostProjectImagePostProjectImagePostProjectImageRequest';
import { ApplicationPostProjectImagePostProjectImagePostProjectImageResponse } from '../model/applicationPostProjectImagePostProjectImagePostProjectImageResponse';
import { ApplicationPostProjectPostProjectPostProjectRequest } from '../model/applicationPostProjectPostProjectPostProjectRequest';
import { ApplicationPostProjectPostProjectPostProjectResponse } from '../model/applicationPostProjectPostProjectPostProjectResponse';
import { ApplicationPostProjectReportPostProjectReportPostProjectReportRequest } from '../model/applicationPostProjectReportPostProjectReportPostProjectReportRequest';
import { ApplicationPostProjectReportPostProjectReportPostProjectReportResponse } from '../model/applicationPostProjectReportPostProjectReportPostProjectReportResponse';
import { ApplicationPostRegisterUserPostRegisterUserPostRegisterUserRequest } from '../model/applicationPostRegisterUserPostRegisterUserPostRegisterUserRequest';
import { ApplicationPostRegisterUserPostRegisterUserPostRegisterUserResponse } from '../model/applicationPostRegisterUserPostRegisterUserPostRegisterUserResponse';
import { ApplicationPostRequestOtpPostRequestOtpPostRequestOtpRequest } from '../model/applicationPostRequestOtpPostRequestOtpPostRequestOtpRequest';
import { ApplicationPostRequestOtpPostRequestOtpPostRequestOtpResponse } from '../model/applicationPostRequestOtpPostRequestOtpPostRequestOtpResponse';
import { ApplicationPutMaterialsPutMaterialsPutMaterialsRequest } from '../model/applicationPutMaterialsPutMaterialsPutMaterialsRequest';
import { ApplicationPutMaterialsPutMaterialsPutMaterialsResponse } from '../model/applicationPutMaterialsPutMaterialsPutMaterialsResponse';
import { ApplicationPutProjectApprovalStatusPutProjectApprovalStatusPutProjectApprovalStatusRequest } from '../model/applicationPutProjectApprovalStatusPutProjectApprovalStatusPutProjectApprovalStatusRequest';
import { ApplicationPutProjectApprovalStatusPutProjectApprovalStatusPutProjectApprovalStatusResponse } from '../model/applicationPutProjectApprovalStatusPutProjectApprovalStatusPutProjectApprovalStatusResponse';
import { ApplicationPutProjectPutProjectPutProjectRequest } from '../model/applicationPutProjectPutProjectPutProjectRequest';
import { ApplicationPutProjectPutProjectPutProjectResponse } from '../model/applicationPutProjectPutProjectPutProjectResponse';
import { ApplicationPutSkillsPutSkillsPutSkillsRequest } from '../model/applicationPutSkillsPutSkillsPutSkillsRequest';
import { ApplicationPutSkillsPutSkillsPutSkillsResponse } from '../model/applicationPutSkillsPutSkillsPutSkillsResponse';
import { ApplicationPutTagsPutTagsPutTagsRequest } from '../model/applicationPutTagsPutTagsPutTagsRequest';
import { ApplicationPutTagsPutTagsPutTagsResponse } from '../model/applicationPutTagsPutTagsPutTagsResponse';
import { Filter } from '../model/filter';
import { Filter1 } from '../model/filter1';
import { Filter2 } from '../model/filter2';
import { Selector } from '../model/selector';
import { Selector1 } from '../model/selector1';
import { Selector2 } from '../model/selector2';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ApiService {

    protected basePath = 'http://api:8081';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * 
     * 
     * @param body 
     * @param projectIdentifier 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public webApiEndpointsDeleteProject(body: ApplicationDeleteProjectDeleteProjectDeleteProjectRequest, projectIdentifier: string, observe?: 'body', reportProgress?: boolean): Observable<ApplicationDeleteProjectDeleteProjectDeleteProjectResponse>;
    public webApiEndpointsDeleteProject(body: ApplicationDeleteProjectDeleteProjectDeleteProjectRequest, projectIdentifier: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplicationDeleteProjectDeleteProjectDeleteProjectResponse>>;
    public webApiEndpointsDeleteProject(body: ApplicationDeleteProjectDeleteProjectDeleteProjectRequest, projectIdentifier: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplicationDeleteProjectDeleteProjectDeleteProjectResponse>>;
    public webApiEndpointsDeleteProject(body: ApplicationDeleteProjectDeleteProjectDeleteProjectRequest, projectIdentifier: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling webApiEndpointsDeleteProject.');
        }

        if (projectIdentifier === null || projectIdentifier === undefined) {
            throw new Error('Required parameter projectIdentifier was null or undefined when calling webApiEndpointsDeleteProject.');
        }

        let headers = this.defaultHeaders;

        // authentication (JWTBearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            '*/*',
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ApplicationDeleteProjectDeleteProjectDeleteProjectResponse>('delete',`${this.basePath}/api/projects/${encodeURIComponent(String(projectIdentifier))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param u 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public webApiEndpointsGetAutocompleteEntries(u?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ApplicationGetAutocompleteEntriesGetAutocompleteEntriesGetAutocompleteEntriesResponse>;
    public webApiEndpointsGetAutocompleteEntries(u?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplicationGetAutocompleteEntriesGetAutocompleteEntriesGetAutocompleteEntriesResponse>>;
    public webApiEndpointsGetAutocompleteEntries(u?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplicationGetAutocompleteEntriesGetAutocompleteEntriesGetAutocompleteEntriesResponse>>;
    public webApiEndpointsGetAutocompleteEntries(u?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (u !== undefined && u !== null) {
            queryParameters = queryParameters.set('_', <any>u);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ApplicationGetAutocompleteEntriesGetAutocompleteEntriesGetAutocompleteEntriesResponse>('get',`${this.basePath}/api/autocomplete-entries`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param u 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public webApiEndpointsGetExample(u?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ApplicationExampleGetExampleGetExampleResponse>;
    public webApiEndpointsGetExample(u?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplicationExampleGetExampleGetExampleResponse>>;
    public webApiEndpointsGetExample(u?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplicationExampleGetExampleGetExampleResponse>>;
    public webApiEndpointsGetExample(u?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (u !== undefined && u !== null) {
            queryParameters = queryParameters.set('_', <any>u);
        }

        let headers = this.defaultHeaders;

        // authentication (JWTBearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ApplicationExampleGetExampleGetExampleResponse>('get',`${this.basePath}/api/example`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param test 
     * @param test2 
     * @param u 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public webApiEndpointsGetExampleAnonymous(test?: string, test2?: string, u?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ApplicationExampleAnonymousGetExampleAnonymousGetExampleAnonymousResponse>;
    public webApiEndpointsGetExampleAnonymous(test?: string, test2?: string, u?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplicationExampleAnonymousGetExampleAnonymousGetExampleAnonymousResponse>>;
    public webApiEndpointsGetExampleAnonymous(test?: string, test2?: string, u?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplicationExampleAnonymousGetExampleAnonymousGetExampleAnonymousResponse>>;
    public webApiEndpointsGetExampleAnonymous(test?: string, test2?: string, u?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (test !== undefined && test !== null) {
            queryParameters = queryParameters.set('test', <any>test);
        }
        if (test2 !== undefined && test2 !== null) {
            queryParameters = queryParameters.set('test2', <any>test2);
        }
        if (u !== undefined && u !== null) {
            queryParameters = queryParameters.set('_', <any>u);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ApplicationExampleAnonymousGetExampleAnonymousGetExampleAnonymousResponse>('get',`${this.basePath}/api/example-anonymous`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectIdentifier 
     * @param u 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public webApiEndpointsGetInternalProject(projectIdentifier: string, u?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ApplicationGetInternalProjectGetInternalProjectGetInternalProjectResponse>;
    public webApiEndpointsGetInternalProject(projectIdentifier: string, u?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplicationGetInternalProjectGetInternalProjectGetInternalProjectResponse>>;
    public webApiEndpointsGetInternalProject(projectIdentifier: string, u?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplicationGetInternalProjectGetInternalProjectGetInternalProjectResponse>>;
    public webApiEndpointsGetInternalProject(projectIdentifier: string, u?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectIdentifier === null || projectIdentifier === undefined) {
            throw new Error('Required parameter projectIdentifier was null or undefined when calling webApiEndpointsGetInternalProject.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (u !== undefined && u !== null) {
            queryParameters = queryParameters.set('_', <any>u);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ApplicationGetInternalProjectGetInternalProjectGetInternalProjectResponse>('get',`${this.basePath}/api/shared/projects/${encodeURIComponent(String(projectIdentifier))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param u 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public webApiEndpointsGetJsonTypeDiscriminatorNames(u?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ApplicationGetJsonTypeDiscriminatorNamesGetJsonTypeDiscriminatorNamesGetJsonTypeDiscriminatorNamesResponse>;
    public webApiEndpointsGetJsonTypeDiscriminatorNames(u?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplicationGetJsonTypeDiscriminatorNamesGetJsonTypeDiscriminatorNamesGetJsonTypeDiscriminatorNamesResponse>>;
    public webApiEndpointsGetJsonTypeDiscriminatorNames(u?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplicationGetJsonTypeDiscriminatorNamesGetJsonTypeDiscriminatorNamesGetJsonTypeDiscriminatorNamesResponse>>;
    public webApiEndpointsGetJsonTypeDiscriminatorNames(u?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (u !== undefined && u !== null) {
            queryParameters = queryParameters.set('_', <any>u);
        }

        let headers = this.defaultHeaders;

        // authentication (JWTBearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ApplicationGetJsonTypeDiscriminatorNamesGetJsonTypeDiscriminatorNamesGetJsonTypeDiscriminatorNamesResponse>('get',`${this.basePath}/api/json-type-discriminator-names`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param u 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public webApiEndpointsGetOtpStatus(u?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ApplicationGetOtpStatusGetOtpStatusGetOtpStatusResponse>;
    public webApiEndpointsGetOtpStatus(u?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplicationGetOtpStatusGetOtpStatusGetOtpStatusResponse>>;
    public webApiEndpointsGetOtpStatus(u?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplicationGetOtpStatusGetOtpStatusGetOtpStatusResponse>>;
    public webApiEndpointsGetOtpStatus(u?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (u !== undefined && u !== null) {
            queryParameters = queryParameters.set('_', <any>u);
        }

        let headers = this.defaultHeaders;

        // authentication (JWTBearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ApplicationGetOtpStatusGetOtpStatusGetOtpStatusResponse>('get',`${this.basePath}/api/users/me/otp`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param withRejectedAndApproved 
     * @param filter 
     * @param selector 
     * @param u 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public webApiEndpointsGetPendingApprovalProjects(withRejectedAndApproved: boolean, filter?: Filter, selector?: Selector, u?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ApplicationGetPendingApprovalProjectsGetPendingApprovalProjectsGetPendingApprovalProjectsResponse>;
    public webApiEndpointsGetPendingApprovalProjects(withRejectedAndApproved: boolean, filter?: Filter, selector?: Selector, u?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplicationGetPendingApprovalProjectsGetPendingApprovalProjectsGetPendingApprovalProjectsResponse>>;
    public webApiEndpointsGetPendingApprovalProjects(withRejectedAndApproved: boolean, filter?: Filter, selector?: Selector, u?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplicationGetPendingApprovalProjectsGetPendingApprovalProjectsGetPendingApprovalProjectsResponse>>;
    public webApiEndpointsGetPendingApprovalProjects(withRejectedAndApproved: boolean, filter?: Filter, selector?: Selector, u?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (withRejectedAndApproved === null || withRejectedAndApproved === undefined) {
            throw new Error('Required parameter withRejectedAndApproved was null or undefined when calling webApiEndpointsGetPendingApprovalProjects.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (withRejectedAndApproved !== undefined && withRejectedAndApproved !== null) {
            queryParameters = queryParameters.set('with-rejected-and-approved', <any>withRejectedAndApproved);
        }
        if (filter !== undefined && filter !== null) {
            queryParameters = queryParameters.set('filter', <any>filter);
        }
        if (selector !== undefined && selector !== null) {
            queryParameters = queryParameters.set('selector', <any>selector);
        }
        if (u !== undefined && u !== null) {
            queryParameters = queryParameters.set('_', <any>u);
        }

        let headers = this.defaultHeaders;

        // authentication (JWTBearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ApplicationGetPendingApprovalProjectsGetPendingApprovalProjectsGetPendingApprovalProjectsResponse>('get',`${this.basePath}/api/approval-projects`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectIdentifier 
     * @param u 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public webApiEndpointsGetProject(projectIdentifier: string, u?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ApplicationGetProjectGetProjectGetProjectResponse>;
    public webApiEndpointsGetProject(projectIdentifier: string, u?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplicationGetProjectGetProjectGetProjectResponse>>;
    public webApiEndpointsGetProject(projectIdentifier: string, u?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplicationGetProjectGetProjectGetProjectResponse>>;
    public webApiEndpointsGetProject(projectIdentifier: string, u?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectIdentifier === null || projectIdentifier === undefined) {
            throw new Error('Required parameter projectIdentifier was null or undefined when calling webApiEndpointsGetProject.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (u !== undefined && u !== null) {
            queryParameters = queryParameters.set('_', <any>u);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ApplicationGetProjectGetProjectGetProjectResponse>('get',`${this.basePath}/api/projects/${encodeURIComponent(String(projectIdentifier))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectIdentifier 
     * @param imageIdentifier 
     * @param thumbnail 
     * @param u 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public webApiEndpointsGetProjectImage(projectIdentifier: string, imageIdentifier: string, thumbnail: boolean, u?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ApplicationGetProjectImageGetProjectImageGetProjectImageResponse>;
    public webApiEndpointsGetProjectImage(projectIdentifier: string, imageIdentifier: string, thumbnail: boolean, u?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplicationGetProjectImageGetProjectImageGetProjectImageResponse>>;
    public webApiEndpointsGetProjectImage(projectIdentifier: string, imageIdentifier: string, thumbnail: boolean, u?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplicationGetProjectImageGetProjectImageGetProjectImageResponse>>;
    public webApiEndpointsGetProjectImage(projectIdentifier: string, imageIdentifier: string, thumbnail: boolean, u?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectIdentifier === null || projectIdentifier === undefined) {
            throw new Error('Required parameter projectIdentifier was null or undefined when calling webApiEndpointsGetProjectImage.');
        }

        if (imageIdentifier === null || imageIdentifier === undefined) {
            throw new Error('Required parameter imageIdentifier was null or undefined when calling webApiEndpointsGetProjectImage.');
        }

        if (thumbnail === null || thumbnail === undefined) {
            throw new Error('Required parameter thumbnail was null or undefined when calling webApiEndpointsGetProjectImage.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (thumbnail !== undefined && thumbnail !== null) {
            queryParameters = queryParameters.set('thumbnail', <any>thumbnail);
        }
        if (u !== undefined && u !== null) {
            queryParameters = queryParameters.set('_', <any>u);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ApplicationGetProjectImageGetProjectImageGetProjectImageResponse>('get',`${this.basePath}/api/projects/${encodeURIComponent(String(projectIdentifier))}/project-images/${encodeURIComponent(String(imageIdentifier))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param filter 
     * @param selector 
     * @param u 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public webApiEndpointsGetProjects(filter?: Filter1, selector?: Selector1, u?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ApplicationGetProjectsGetProjectsGetProjectsResponse>;
    public webApiEndpointsGetProjects(filter?: Filter1, selector?: Selector1, u?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplicationGetProjectsGetProjectsGetProjectsResponse>>;
    public webApiEndpointsGetProjects(filter?: Filter1, selector?: Selector1, u?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplicationGetProjectsGetProjectsGetProjectsResponse>>;
    public webApiEndpointsGetProjects(filter?: Filter1, selector?: Selector1, u?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (filter !== undefined && filter !== null) {
            queryParameters = queryParameters.set('filter', <any>filter);
        }
        if (selector !== undefined && selector !== null) {
            queryParameters = queryParameters.set('selector', <any>selector);
        }
        if (u !== undefined && u !== null) {
            queryParameters = queryParameters.set('_', <any>u);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ApplicationGetProjectsGetProjectsGetProjectsResponse>('get',`${this.basePath}/api/projects`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectIdentifier 
     * @param u 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public webApiEndpointsGetUsersProject(projectIdentifier: string, u?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ApplicationGetUsersProjectGetUsersProjectGetUsersProjectResponse>;
    public webApiEndpointsGetUsersProject(projectIdentifier: string, u?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplicationGetUsersProjectGetUsersProjectGetUsersProjectResponse>>;
    public webApiEndpointsGetUsersProject(projectIdentifier: string, u?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplicationGetUsersProjectGetUsersProjectGetUsersProjectResponse>>;
    public webApiEndpointsGetUsersProject(projectIdentifier: string, u?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectIdentifier === null || projectIdentifier === undefined) {
            throw new Error('Required parameter projectIdentifier was null or undefined when calling webApiEndpointsGetUsersProject.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (u !== undefined && u !== null) {
            queryParameters = queryParameters.set('_', <any>u);
        }

        let headers = this.defaultHeaders;

        // authentication (JWTBearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ApplicationGetUsersProjectGetUsersProjectGetUsersProjectResponse>('get',`${this.basePath}/api/my/projects/${encodeURIComponent(String(projectIdentifier))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param filter 
     * @param selector 
     * @param u 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public webApiEndpointsGetUsersProjects(filter?: Filter2, selector?: Selector2, u?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ApplicationGetUsersProjectsGetUsersProjectsGetUsersProjectsResponse>;
    public webApiEndpointsGetUsersProjects(filter?: Filter2, selector?: Selector2, u?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplicationGetUsersProjectsGetUsersProjectsGetUsersProjectsResponse>>;
    public webApiEndpointsGetUsersProjects(filter?: Filter2, selector?: Selector2, u?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplicationGetUsersProjectsGetUsersProjectsGetUsersProjectsResponse>>;
    public webApiEndpointsGetUsersProjects(filter?: Filter2, selector?: Selector2, u?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (filter !== undefined && filter !== null) {
            queryParameters = queryParameters.set('filter', <any>filter);
        }
        if (selector !== undefined && selector !== null) {
            queryParameters = queryParameters.set('selector', <any>selector);
        }
        if (u !== undefined && u !== null) {
            queryParameters = queryParameters.set('_', <any>u);
        }

        let headers = this.defaultHeaders;

        // authentication (JWTBearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ApplicationGetUsersProjectsGetUsersProjectsGetUsersProjectsResponse>('get',`${this.basePath}/api/my/projects`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public webApiEndpointsJwtRefreshToken(body: ApplicationJwtRefreshTokenJwtRefreshTokenJwtRefreshTokenRequest, observe?: 'body', reportProgress?: boolean): Observable<ApplicationJwtRefreshTokenJwtRefreshTokenJwtRefreshTokenResponse>;
    public webApiEndpointsJwtRefreshToken(body: ApplicationJwtRefreshTokenJwtRefreshTokenJwtRefreshTokenRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplicationJwtRefreshTokenJwtRefreshTokenJwtRefreshTokenResponse>>;
    public webApiEndpointsJwtRefreshToken(body: ApplicationJwtRefreshTokenJwtRefreshTokenJwtRefreshTokenRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplicationJwtRefreshTokenJwtRefreshTokenJwtRefreshTokenResponse>>;
    public webApiEndpointsJwtRefreshToken(body: ApplicationJwtRefreshTokenJwtRefreshTokenJwtRefreshTokenRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling webApiEndpointsJwtRefreshToken.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ApplicationJwtRefreshTokenJwtRefreshTokenJwtRefreshTokenResponse>('post',`${this.basePath}/api/refresh-token`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public webApiEndpointsJwtToken(body: ApplicationJwtTokenJwtTokenRequest, observe?: 'body', reportProgress?: boolean): Observable<ApplicationJwtTokenJwtTokenResponse>;
    public webApiEndpointsJwtToken(body: ApplicationJwtTokenJwtTokenRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplicationJwtTokenJwtTokenResponse>>;
    public webApiEndpointsJwtToken(body: ApplicationJwtTokenJwtTokenRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplicationJwtTokenJwtTokenResponse>>;
    public webApiEndpointsJwtToken(body: ApplicationJwtTokenJwtTokenRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling webApiEndpointsJwtToken.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ApplicationJwtTokenJwtTokenResponse>('post',`${this.basePath}/api/token`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public webApiEndpointsPostConfirmOtp(body: ApplicationPostConfirmOtpPostConfirmOtpPostConfirmOtpRequest, observe?: 'body', reportProgress?: boolean): Observable<ApplicationPostConfirmOtpPostConfirmOtpPostConfirmOtpResponse>;
    public webApiEndpointsPostConfirmOtp(body: ApplicationPostConfirmOtpPostConfirmOtpPostConfirmOtpRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplicationPostConfirmOtpPostConfirmOtpPostConfirmOtpResponse>>;
    public webApiEndpointsPostConfirmOtp(body: ApplicationPostConfirmOtpPostConfirmOtpPostConfirmOtpRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplicationPostConfirmOtpPostConfirmOtpPostConfirmOtpResponse>>;
    public webApiEndpointsPostConfirmOtp(body: ApplicationPostConfirmOtpPostConfirmOtpPostConfirmOtpRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling webApiEndpointsPostConfirmOtp.');
        }

        let headers = this.defaultHeaders;

        // authentication (JWTBearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ApplicationPostConfirmOtpPostConfirmOtpPostConfirmOtpResponse>('post',`${this.basePath}/api/users/me/otp-confirm`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public webApiEndpointsPostProject(body: ApplicationPostProjectPostProjectPostProjectRequest, observe?: 'body', reportProgress?: boolean): Observable<ApplicationPostProjectPostProjectPostProjectResponse>;
    public webApiEndpointsPostProject(body: ApplicationPostProjectPostProjectPostProjectRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplicationPostProjectPostProjectPostProjectResponse>>;
    public webApiEndpointsPostProject(body: ApplicationPostProjectPostProjectPostProjectRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplicationPostProjectPostProjectPostProjectResponse>>;
    public webApiEndpointsPostProject(body: ApplicationPostProjectPostProjectPostProjectRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling webApiEndpointsPostProject.');
        }

        let headers = this.defaultHeaders;

        // authentication (JWTBearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ApplicationPostProjectPostProjectPostProjectResponse>('post',`${this.basePath}/api/projects`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param projectIdentifier 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public webApiEndpointsPostProjectImage(body: ApplicationPostProjectImagePostProjectImagePostProjectImageRequest, projectIdentifier: string, observe?: 'body', reportProgress?: boolean): Observable<ApplicationPostProjectImagePostProjectImagePostProjectImageResponse>;
    public webApiEndpointsPostProjectImage(body: ApplicationPostProjectImagePostProjectImagePostProjectImageRequest, projectIdentifier: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplicationPostProjectImagePostProjectImagePostProjectImageResponse>>;
    public webApiEndpointsPostProjectImage(body: ApplicationPostProjectImagePostProjectImagePostProjectImageRequest, projectIdentifier: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplicationPostProjectImagePostProjectImagePostProjectImageResponse>>;
    public webApiEndpointsPostProjectImage(body: ApplicationPostProjectImagePostProjectImagePostProjectImageRequest, projectIdentifier: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling webApiEndpointsPostProjectImage.');
        }

        if (projectIdentifier === null || projectIdentifier === undefined) {
            throw new Error('Required parameter projectIdentifier was null or undefined when calling webApiEndpointsPostProjectImage.');
        }

        let headers = this.defaultHeaders;

        // authentication (JWTBearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ApplicationPostProjectImagePostProjectImagePostProjectImageResponse>('post',`${this.basePath}/api/projects/${encodeURIComponent(String(projectIdentifier))}/project-images`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param entityId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public webApiEndpointsPostProjectReport(body: ApplicationPostProjectReportPostProjectReportPostProjectReportRequest, entityId: string, observe?: 'body', reportProgress?: boolean): Observable<ApplicationPostProjectReportPostProjectReportPostProjectReportResponse>;
    public webApiEndpointsPostProjectReport(body: ApplicationPostProjectReportPostProjectReportPostProjectReportRequest, entityId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplicationPostProjectReportPostProjectReportPostProjectReportResponse>>;
    public webApiEndpointsPostProjectReport(body: ApplicationPostProjectReportPostProjectReportPostProjectReportRequest, entityId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplicationPostProjectReportPostProjectReportPostProjectReportResponse>>;
    public webApiEndpointsPostProjectReport(body: ApplicationPostProjectReportPostProjectReportPostProjectReportRequest, entityId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling webApiEndpointsPostProjectReport.');
        }

        if (entityId === null || entityId === undefined) {
            throw new Error('Required parameter entityId was null or undefined when calling webApiEndpointsPostProjectReport.');
        }

        let headers = this.defaultHeaders;

        // authentication (JWTBearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ApplicationPostProjectReportPostProjectReportPostProjectReportResponse>('post',`${this.basePath}/api/projects/${encodeURIComponent(String(entityId))}/report`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public webApiEndpointsPostRegisterUser(body: ApplicationPostRegisterUserPostRegisterUserPostRegisterUserRequest, observe?: 'body', reportProgress?: boolean): Observable<ApplicationPostRegisterUserPostRegisterUserPostRegisterUserResponse>;
    public webApiEndpointsPostRegisterUser(body: ApplicationPostRegisterUserPostRegisterUserPostRegisterUserRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplicationPostRegisterUserPostRegisterUserPostRegisterUserResponse>>;
    public webApiEndpointsPostRegisterUser(body: ApplicationPostRegisterUserPostRegisterUserPostRegisterUserRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplicationPostRegisterUserPostRegisterUserPostRegisterUserResponse>>;
    public webApiEndpointsPostRegisterUser(body: ApplicationPostRegisterUserPostRegisterUserPostRegisterUserRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling webApiEndpointsPostRegisterUser.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ApplicationPostRegisterUserPostRegisterUserPostRegisterUserResponse>('post',`${this.basePath}/api/users`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public webApiEndpointsPostRequestOtp(body: ApplicationPostRequestOtpPostRequestOtpPostRequestOtpRequest, observe?: 'body', reportProgress?: boolean): Observable<ApplicationPostRequestOtpPostRequestOtpPostRequestOtpResponse>;
    public webApiEndpointsPostRequestOtp(body: ApplicationPostRequestOtpPostRequestOtpPostRequestOtpRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplicationPostRequestOtpPostRequestOtpPostRequestOtpResponse>>;
    public webApiEndpointsPostRequestOtp(body: ApplicationPostRequestOtpPostRequestOtpPostRequestOtpRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplicationPostRequestOtpPostRequestOtpPostRequestOtpResponse>>;
    public webApiEndpointsPostRequestOtp(body: ApplicationPostRequestOtpPostRequestOtpPostRequestOtpRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling webApiEndpointsPostRequestOtp.');
        }

        let headers = this.defaultHeaders;

        // authentication (JWTBearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ApplicationPostRequestOtpPostRequestOtpPostRequestOtpResponse>('post',`${this.basePath}/api/users/me/otp-request`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public webApiEndpointsPutMaterials(body: ApplicationPutMaterialsPutMaterialsPutMaterialsRequest, observe?: 'body', reportProgress?: boolean): Observable<ApplicationPutMaterialsPutMaterialsPutMaterialsResponse>;
    public webApiEndpointsPutMaterials(body: ApplicationPutMaterialsPutMaterialsPutMaterialsRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplicationPutMaterialsPutMaterialsPutMaterialsResponse>>;
    public webApiEndpointsPutMaterials(body: ApplicationPutMaterialsPutMaterialsPutMaterialsRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplicationPutMaterialsPutMaterialsPutMaterialsResponse>>;
    public webApiEndpointsPutMaterials(body: ApplicationPutMaterialsPutMaterialsPutMaterialsRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling webApiEndpointsPutMaterials.');
        }

        let headers = this.defaultHeaders;

        // authentication (JWTBearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ApplicationPutMaterialsPutMaterialsPutMaterialsResponse>('put',`${this.basePath}/api/materials`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param entityId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public webApiEndpointsPutProject(body: ApplicationPutProjectPutProjectPutProjectRequest, entityId: string, observe?: 'body', reportProgress?: boolean): Observable<ApplicationPutProjectPutProjectPutProjectResponse>;
    public webApiEndpointsPutProject(body: ApplicationPutProjectPutProjectPutProjectRequest, entityId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplicationPutProjectPutProjectPutProjectResponse>>;
    public webApiEndpointsPutProject(body: ApplicationPutProjectPutProjectPutProjectRequest, entityId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplicationPutProjectPutProjectPutProjectResponse>>;
    public webApiEndpointsPutProject(body: ApplicationPutProjectPutProjectPutProjectRequest, entityId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling webApiEndpointsPutProject.');
        }

        if (entityId === null || entityId === undefined) {
            throw new Error('Required parameter entityId was null or undefined when calling webApiEndpointsPutProject.');
        }

        let headers = this.defaultHeaders;

        // authentication (JWTBearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ApplicationPutProjectPutProjectPutProjectResponse>('put',`${this.basePath}/api/projects/${encodeURIComponent(String(entityId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param entityId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public webApiEndpointsPutProjectApprovalStatus(body: ApplicationPutProjectApprovalStatusPutProjectApprovalStatusPutProjectApprovalStatusRequest, entityId: string, observe?: 'body', reportProgress?: boolean): Observable<ApplicationPutProjectApprovalStatusPutProjectApprovalStatusPutProjectApprovalStatusResponse>;
    public webApiEndpointsPutProjectApprovalStatus(body: ApplicationPutProjectApprovalStatusPutProjectApprovalStatusPutProjectApprovalStatusRequest, entityId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplicationPutProjectApprovalStatusPutProjectApprovalStatusPutProjectApprovalStatusResponse>>;
    public webApiEndpointsPutProjectApprovalStatus(body: ApplicationPutProjectApprovalStatusPutProjectApprovalStatusPutProjectApprovalStatusRequest, entityId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplicationPutProjectApprovalStatusPutProjectApprovalStatusPutProjectApprovalStatusResponse>>;
    public webApiEndpointsPutProjectApprovalStatus(body: ApplicationPutProjectApprovalStatusPutProjectApprovalStatusPutProjectApprovalStatusRequest, entityId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling webApiEndpointsPutProjectApprovalStatus.');
        }

        if (entityId === null || entityId === undefined) {
            throw new Error('Required parameter entityId was null or undefined when calling webApiEndpointsPutProjectApprovalStatus.');
        }

        let headers = this.defaultHeaders;

        // authentication (JWTBearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ApplicationPutProjectApprovalStatusPutProjectApprovalStatusPutProjectApprovalStatusResponse>('post',`${this.basePath}/api/projects/${encodeURIComponent(String(entityId))}/approval-status`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public webApiEndpointsPutSkills(body: ApplicationPutSkillsPutSkillsPutSkillsRequest, observe?: 'body', reportProgress?: boolean): Observable<ApplicationPutSkillsPutSkillsPutSkillsResponse>;
    public webApiEndpointsPutSkills(body: ApplicationPutSkillsPutSkillsPutSkillsRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplicationPutSkillsPutSkillsPutSkillsResponse>>;
    public webApiEndpointsPutSkills(body: ApplicationPutSkillsPutSkillsPutSkillsRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplicationPutSkillsPutSkillsPutSkillsResponse>>;
    public webApiEndpointsPutSkills(body: ApplicationPutSkillsPutSkillsPutSkillsRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling webApiEndpointsPutSkills.');
        }

        let headers = this.defaultHeaders;

        // authentication (JWTBearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ApplicationPutSkillsPutSkillsPutSkillsResponse>('put',`${this.basePath}/api/skills`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public webApiEndpointsPutTags(body: ApplicationPutTagsPutTagsPutTagsRequest, observe?: 'body', reportProgress?: boolean): Observable<ApplicationPutTagsPutTagsPutTagsResponse>;
    public webApiEndpointsPutTags(body: ApplicationPutTagsPutTagsPutTagsRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplicationPutTagsPutTagsPutTagsResponse>>;
    public webApiEndpointsPutTags(body: ApplicationPutTagsPutTagsPutTagsRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplicationPutTagsPutTagsPutTagsResponse>>;
    public webApiEndpointsPutTags(body: ApplicationPutTagsPutTagsPutTagsRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling webApiEndpointsPutTags.');
        }

        let headers = this.defaultHeaders;

        // authentication (JWTBearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ApplicationPutTagsPutTagsPutTagsResponse>('put',`${this.basePath}/api/tags`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
